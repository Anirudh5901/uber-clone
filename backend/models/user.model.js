const mongoose = require("mongoose");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");

const userSchema = new mongoose.Schema({
  fullName: {
    firstName: {
      type: String,
      required: true,
      minlength: [3, "First name must be atleast 3 characters long"],
    },
    lastName: {
      type: String,
      minlength: [3, "Last name must be atleast 3 characters long"],
    },
  },
  email: {
    type: String,
    required: true,
    unique: true,
    minLength: [5, "Email must be atleast 5 characters long"],
  },
  password: {
    type: String,
    required: true,
    select: false, //When you set select: false on a field in a Mongoose schema, that field is not returned in the results of queries (e.g., find, findOne, findById) unless you explicitly include it using the select() method or a projection.
  },
  socketId: {
    type: String,
  },
});

//custom method addition to the schema
userSchema.methods.generateAuthToken = function () {
  //Defines a new method named generateAuthToken on the userSchemaâ€™s methods object, making it available on all instances of the User model.
  const token = jwt.sign({ _id: this._id }, process.env.JWT_SECRET); //this._id is the one generated by mongoDB
  return token;
};

userSchema.methods.comparePassword = async function (password) {
  return await bcrypt.compare(password, this.password);
};

userSchema.statics.hashPassword = async function (password) {
  //methods defines instance methods (called on a document, e.g., user.hashPassword).statics defines static methods (called on the model, e.g., userModel.hashPassword).
  return await bcrypt.hash(password, 10);
};

const userModel = mongoose.model("user", userSchema);

module.exports = userModel;

//we will create routes but the logic will be in the controllers.
